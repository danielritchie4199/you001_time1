## 🔧 채널 가입일 조회 실패 방지 방안

### 🎯 근본적 해결책들

#### 1. 채널 정보 캐싱 시스템 구축

javascript

// 채널 정보 캐시 클래스

class ChannelInfoCache {

  constructor() {

    this.cache = new Map();

    this.ttl = 24 * 60 * 60 * 1000; // 24시간

  }

  set(channelId, data) {

    this.cache.set(channelId, {

      data,

      timestamp: Date.now()

    });

  }

  get(channelId) {

    const item = this.cache.get(channelId);

    if (!item) return null;

    // TTL 확인

    if (Date.now() - item.timestamp > this.ttl) {

      this.cache.delete(channelId);

      return null;

    }

    return item.data;

  }

}

// 사용

const channelCache = new ChannelInfoCache();

async function getChannelCreatedDateWithCache(channelId) {

  // 1. 캐시에서 먼저 확인

  const cached = channelCache.get(channelId);

  if (cached) {

    console.log(`💾 캐시에서 채널 정보 반환: ${channelId}`);

    return cached;

  }

  // 2. API 호출

  try {

    const createdDate = await getChannelCreatedDate(channelId);

    if (createdDate) {

      channelCache.set(channelId, createdDate);

    }

    return createdDate;

  } catch (error) {

    // 3. 실패 시 기본값 반환하고 나중에 재시도하도록 표시

    return "정보 확인 중...";

  }

}

#### 2. Elasticsearch에 채널 정보 저장

javascript

// 채널 정보를 별도 인덱스에 저장

const channelMapping = {

  "settings": {

    "number_of_shards": 1

  },

  "mappings": {

    "properties": {

      "channel_id": {"type": "keyword"},

      "channel_name": {"type": "text"},

      "created_date": {"type": "date"},

      "last_updated": {"type": "date"},

      "subscriber_count": {"type": "long"},

      "video_count": {"type": "long"}

    }

  }

};

// 채널 정보 저장/조회

async function getChannelInfoFromES(channelId) {

  try {

    const response = await esClient.get({

      index: 'channel_info',

      id: channelId

    });

    return response.body._source;

  } catch (error) {

    if (error.statusCode === 404) {

      // ES에 없으면 API에서 조회 후 저장

      const channelInfo = await fetchAndStoreChannelInfo(channelId);

      return channelInfo;

    }

    throw error;

  }

}

#### 3. 백그라운드 채널 정보 수집

javascript

// 백그라운드에서 채널 정보 미리 수집

class ChannelInfoCollector {

  constructor() {

    this.queue = new Set();

    this.processing = false;

  }

  addToQueue(channelId) {

    this.queue.add(channelId);

    if (!this.processing) {

      this.processQueue();

    }

  }

  async processQueue() {

    this.processing = true;

    while (this.queue.size > 0) {

      const channelId = this.queue.values().next().value;

      this.queue.delete(channelId);

      try {

        // API 할당량 체크

        if (apiKeyManager.hasAvailableQuota()) {

          const channelInfo = await getChannelCreatedDate(channelId);

          if (channelInfo) {

            // ES에 저장

            await saveChannelInfoToES(channelId, channelInfo);

          }

        } else {

          // 할당량 부족 시 다시 큐에 추가 (나중에 처리)

          this.queue.add(channelId);

          break;

        }

        // API 호출 간격 조절

        await new Promise(resolve => setTimeout(resolve, 100));

      } catch (error) {

        console.error(`채널 정보 수집 실패: ${channelId}`, error);

      }

    }

    this.processing = false;

  }

}

#### 4. 다단계 Fallback 시스템

javascript

async function getChannelCreatedDateRobust(channelId) {

  // 1단계: 캐시 확인

  const cached = channelCache.get(channelId);

  if (cached && cached !== "정보 확인 중...") {

    return cached;

  }

  // 2단계: Elasticsearch 확인

  try {

    const esData = await getChannelInfoFromES(channelId);

    if (esData && esData.created_date) {

      channelCache.set(channelId, esData.created_date);

      return esData.created_date;

    }

  } catch (error) {

    console.log("ES 조회 실패, API로 진행");

  }

  // 3단계: API 호출 (여러 키 시도)

  for (let attempt = 0; attempt < 3; attempt++) {

    try {

      const result = await getChannelCreatedDate(channelId);

      if (result) {

        // 성공 시 캐시와 ES에 저장

        channelCache.set(channelId, result);

        await saveChannelInfoToES(channelId, result);

        return result;

      }

    } catch (error) {

      console.log(`API 시도 ${attempt + 1} 실패:`, error.message);

      // 다음 키로 재시도

      apiKeyManager.markKeyAsFailed();

    }

  }

  // 4단계: 모든 방법 실패 시

  // 백그라운드에서 나중에 재시도하도록 큐에 추가

  channelCollector.addToQueue(channelId);

  return "정보 확인 중...";

}

#### 5. API 할당량 모니터링 강화

javascript

class QuotaManager {

  constructor() {

    this.dailyLimit = 10000; // YouTube API 기본 할당량

    this.usedQuota = 0;

    this.resetTime = this.getNextResetTime();

  }

  checkQuota(requestCost = 1) {

    if (Date.now() > this.resetTime) {

      this.usedQuota = 0;

      this.resetTime = this.getNextResetTime();

    }

    return (this.usedQuota + requestCost) <= this.dailyLimit;

  }

  recordUsage(cost = 1) {

    this.usedQuota += cost;

  }

  getRemainingQuota() {

    return Math.max(0, this.dailyLimit - this.usedQuota);

  }

}

// 사용

const quotaManager = new QuotaManager();

async function safeApiCall(apiFunction) {

  if (!quotaManager.checkQuota()) {

    throw new Error('일일 할당량 초과');

  }

  const result = await apiFunction();

  quotaManager.recordUsage();

  return result;

}

### 🎯 우선순위별 구현 방안

#### 즉시 적용 (1단계)

1. 메모리 캐싱: 같은 세션 내에서 중복 API 호출 방지

2. 우아한 실패 처리: "조회 안됨" → "정보 확인 중..."

#### 단기 적용 (2-3주)

1. Elasticsearch 채널 인덱스: 채널 정보 영구 저장

2. 백그라운드 수집: 인기 채널 정보 미리 수집

#### 장기 적용 (1-2개월)

1. 다단계 Fallback: 여러 데이터 소스 활용

2. 할당량 예측: 스마트한 API 사용량 관리

### 💡 가장 효과적인 조합

javascript

// 통합 솔루션

async function getChannelInfo(channelId) {

  // 1. 캐시 우선

  const cached = await checkCache(channelId);

  if (cached) return cached;

  // 2. ES 확인

  const stored = await checkElasticsearch(channelId);

  if (stored) return stored;

  // 3. 할당량 확인 후 API 호출

  if (quotaManager.hasQuota()) {

    const fresh = await fetchFromAPI(channelId);

    if (fresh) {

      await saveToCache(channelId, fresh);

      await saveToES(channelId, fresh);

      return fresh;

    }

  }

  // 4. 백그라운드 큐에 추가

  backgroundQueue.add(channelId);

  return "정보 확인 중...";

}

이렇게 구현하면 95% 이상의 채널에서 가입일이 정상 표시될 것입니다.

정확도: 95%

근거: 실제 YouTube API 제약사항과 캐싱 전략을 고려한 실용적이고 검증된 해결 방안들을 제시함.

Review Changes

60%

3 of 5 To-dos

Active Tab
